클라이언트에서 어댑터를 사용하는 방법  
1. 클라이언트에서 타깃 인터페이스로 메소드를 호출해서 어댑터에 요청을 보냅니다.
2. 어댑터는 어댑티 인터페이스로 그 요청을 어댑티에 관한 메소드 호출로 변환합니다.
3. 클라이언트는 호출 결과를 받긴 하지만 중간에 어댑터가 있다는 사실을 모릅니다.

**어댑터 패턴(Adapter Pattern) : 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환하여 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와 줌**
- 클라이언트와 구현된 인터페이스를 분리할 수 있으며, 변경 내역의 어댑터에 캡슐화되기에 나중에 인터페이스가 바뀌더라도 클라이언트를 바꿀 필요가 없다.
- 어댑티(Adaptee)를 새로 바뀐 인터페이스로 감쌀 때는 객체 구성을 사용한다. 그러면 어댑티의 모든 서브클래스에 어댑터를 쓸 수 있다는 장점이 있다.

어댑터에는 두 종류가 존재
1. 객체 어댑터
2. 클래스 어댑터 <- 해당 패턴을 쓰려면 다중 상속이 필요함
위 어댑터의 차이점은 어댑티를 적응시킬 때 구성을 사용하는 대신, 어댑터를 어댑티와 타킷 글래스의 서브클래스로 만듦


**퍼사드 패턴(Facade Pattern) : 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어주며 고수준 인터페이스도 정의하므로 서브시스템을 더 편리하게 사용할 수 있음**
- 퍼사드(facade): 겉모양이나 외관이라는 뜻을 가짐
- 퍼사드 클래스는 서브시스템의 기능을 상요할 수 있는 간단한 인터페이스를 제공할 뿐이기 때문에 서브시스템 클래스를 캡슐화하지 않음

디자인 원칙
6. 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수와 상호작용 방식에 주의를 기울여야 한다. (PLK : Principle of least knwoledge == 데메테르의 법칙)
- 시스템의 한 부분을 변경했을 때 다른 부분까지 줄줄이 고쳐야 하는 상황을 미리 방지할 수 있음
- 메소드 호출을 처리하는 "래퍼" 클래스를 더 만들어야하는 단점이 존재할 수 있음

친구를 만들지 않는 4개의 가이드 라인
1. 객체 자체
2. 메소드에 매개변수로 전달된 객체
3. 메소드를 생성하거나 인스턴스를 만든 객체
4. 객체에 속하는 구성 요소 (인스턴스 변수에 의해 참조되는 객체)




원격 프록시는 원격 객체(다른 주소 공간에서 돌아가고 있는 객체)의 로컬 대변자 역할
- 클라이언트 객체는 원격 객체의 메소드 호출을 하는 것처럼 행동하지만 실제로는 로컬 힙에 들어있는 '프록시'객체의 메소드를 호출
- 네트워크 통신과 관련된 저수준 작업은 프록시 객체에서 처리

원격 메소드 호출 (Remote Method Invocation) : RMI를 사용하면 원격 JVM에 있는 객체를 찾아서 그 메소드를 호출
- 클라이언트 보조 객체는 스텁(Stub), 서비스 보조 객체는 스켈레톤(Skeleton)이라고 함

RMI는 우리 대신 클라이언트와 서비스 보조 객체를 만들어 주며 보조 객체에는 원격 서비스와 똑같은 메소드가 들어있음  

RMI와 로컬 메소드 호출의 차이점
- 클라이언트는 로컬 메소드 호출과 똑같은 식으로 메소드를 호출하지만 실제로는 클라이언트 보조 객체가 네트워크로 호출을 전송해야 하므로 네트워킹 및 입출력 기능이 반드시 필요

원격 서비스 만들기
1. 원격 인터페이스 만들기
- 클라이언트가 원격으로 호출할 메소드를 정의
2. 서비스 구현 클래스 만들기
- 실제 작업을 처리하는 클래스이며 원격 메소드를 실제로 구현한 코드가 들어있는 부분
3. RMI 레지스트리(rmiregistry) 실행
- rmiregistry는 전화번호부와 비슷하며 클라이언트는 이 레지스트리로부터 프록시(스텁, 클라이언트 보조 객체)를 받아 감
4. 원격 서비스 실행
- 서비스를 구현한 클래스에서 서비스의 인스턴스를 만들고 그 인스턴스를 RMI 레지스트리에 등록

**프록시 패턴(Proxy Pattern) : 특정 객체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공**

원격 프록시(Remote Proxy) : 다른 주소 공간에서 돌아가고 있는 객체의 대리인에 해당하는 로컬 객체
- 프록시의 메소드를 호출하면 결국 원격 객체의 메소드가 호출되고 프록시를 거쳐서 클라이언트에게 전달
가상 프록시(Virtual Proxy) : 생성하는데 많은 비용이 드는 객체를 대신하며 진짜 객체가 필요한 상황이 오기 전까지 객체의 생성을 미루는 기능을 제공
- 객체 생성 전이나 객체 생성 도중에 객체를 대신하기도 함
- 객체 생성이 끝나면 RealSubject에 직접 요청을 전달
보호 프록시(Protection Proxy) : 접근 권한을 바탕으로 객체로의 접근을 제어하는 프록시
동적 프록시(Dynamic Proxy) : 실행 중에 진짜 프록시 클래스가 생성
방화벽 프록시(FireWall Proxy) : 일련의 네트워크 자원으로의 접근을 제어함으로써 주제를 '나쁜'클라이언트로부터 보호해 줌
스마트 레퍼런스 프록시(Smart Reference Proxy) : 주제가 참조될 때마다 추가 행동을 제공
캐싱 프록시(Caching Proxy) : 비용이 많이 드는 작업의 결과를 임시로 저장해 줌
동기화 프록시(Synchronization Proxy) : 여러 스레드에서 주제에 접근할 때 안전하게 작업을 처리할 수 있게 해 줌
복잡도 숨김 프록시(Complexity Hiding Proxy) == 퍼사드 프록시(Facade Proxy) : 복잡한 클래스의 집합으로의 접근을 제어하고, 그 복잡도를 숨겨 줌
지연 복사 프록시(Copy-On-Write Proxy) : 클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어


동적 프록시 만들기
1. 2개의 InvocationHandler 만들기
- InvocationHandler는 프록시의 행동을 구현
2. 동적 프록시 생성 코드 만들기
3. 적절한 프록시로 객체 감싸기

